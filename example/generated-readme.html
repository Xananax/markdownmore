<html><head><title>Markdown-Additions Examples</title></head><body><h1>TOC</h1><ul class="toc"><li><a href="#toc-markdown-more">Markdown-More</a></li><li><a href="#toc-api">API</a></li><li><a href="#toc-examples">Examples:</a></li><li><a href="#toc-license">LICENSE</a></li></ul>

<h1 id="toc-markdown-more">Markdown-More</h1>

<p>Little additions on top of <a href="https://github.com/evilstreak/markdown-js">markdown-js</a>.<br/>Comes with a little set of helpers to register filters easily. Uses the <a href="https://github.com/bhollis/maruku/blob/master/docs/markdown_syntax.md">&quot;Maruku&quot;</a> dialect by default, which means it supports:</p>

<table><thead><tr><th>tables</th><th>like</th><th>this</th></tr></thead><tbody><tr><td>a</td><td>b</td><td>c</td></tr></tbody></table>

<h3 id="toc-api">API</h3>

<h4>Markdown(string[,locals])</h4>

<p>equivalent to the original <code>markdown.toHTML()</code>, but goes through all the filters before rendering. <code>locals</code> is anything you want to pass to your functions.</p>

<h4>Markdown.register(hook)</h4>

<p>Returns a function <code>register(function)</code> that allows to register functions on the defined hook. Hooks are (in order):</p>

<ul><li>&#39;before&#39;: acts on the raw string</li><li>&#39;json&#39;: acts on the jsonmlTree</li><li>&#39;html&#39;: acts on the htmlTree</li><li>&#39;after&#39;: acts on the raw html string</li></ul>

<p><span>Example:<br/></span><code><span>js<br/>var register_html = markdown.register(&#39;html&#39;);<br/>register_html(func1);<br/></span></code></p>

<p><strong>Note</strong>: Function order <strong>MATTERS</strong>.</p>

<h4>Markdown.register(hook,function)</h4>

<p>Registers a function at a particular hook.<br/>All functions have a signature of <code>function(data,locals)</code>, where <code>locals</code> is whatever you passed down to <code>markdown()</code> and <code>data</code> is:</p>

<ul><li>Functions defined in &#39;before&#39; and &#39;after&#39; receive an object {str:string}, where the string is respectively the raw text and the raw html</li><li>Functions defined in &#39;json&#39; receive the jsonml tree</li><li>Functions defined in &#39;html&#39; receive the html tree</li></ul>

<p><span>All functions are expected to work on the first argument passed and shouldn&#39;t return anything.<br/></span><code>Markdown.register(hook,function)</code><span> returns a curried version of itself, so you can chain, for example:<br/></span><code><span>js<br/>markdown.register(&#39;json&#39;)(func1)(func2)(func3);<br/>//is equivalent to<br/>markdown.register(&#39;json&#39;)(func1);<br/>markdown.register(&#39;json&#39;)(func2);<br/>markdown.register(&#39;json&#39;)(func3);<br/></span></code></p>

<h4>Markdown.makeJsonFilter(function)</h4>

<p>Registers a function at json level. Will go through every item in the jsonml array, and passe them to the function. The function is tasked with returning explicitely <code>false</code> for every item it does <em>not</em> want to parse.</p>

<h4>Markdown.makeJsonFilter(RegExp[,baseElem],parse)</h4>

<p>Registers a json filter that uses the provided RegExp to parse the tree. The <code>parse</code> function passed should have a signature of: <code>function(chunk,locals)</code>, where <code>locals</code> is whatever you passed, <code>chunk</code> is the current processed chunk of text that matches the RegExp you provided, and <code>baseElem</code><span> is how you want your returned element to be wrapped (&#39;text&#39;,&#39;para&#39;...), and defaults to &#39;text&#39;.<br/></span><code>this.regExp</code> will be filled with the regExp you provided.<br/><span>Here is an easy example to turn line returns into &lt;br&gt;:<br/></span><code><span>js<br/>var lineReturnsFilter = markdown.makeJsonFilter(/(\n|\r)/g,&#39;text&#39;,function(chunk){<br/>    if(chunk.match(this.regExp)){<br/>        return [&#39;linebreak&#39;];<br/>    }<br/>    return chunk;<br/>});<br/>markdown.register(&#39;json&#39;,lineReturnsFilter);<br/></span></code></p>

<h4>Markdown.registerJsonFilter(RegExp,baseElem,parse)</h4>

<p>Same as <code>makeJsonFilter</code>, but avoids the step of having to register the function.</p>

<h3 id="toc-examples">Examples:</h3>

<p>You&#39;ll find a few examples in <code>example/filter.js</code>, namely to:</p>

<ul><li><span>turn &quot;<label class="checkbox" for="checkbox0"><input type="checkbox" tabindex="0" class="input-checkbox" id="checkbox0" checked="checked"></input><span class="checkbox-label">abcde</span></label>&quot; into checkboxes, <label class="checkbox" for="checkbox1"><input type="checkbox" tabindex="1" class="input-checkbox" id="checkbox1"></input><span class="checkbox-label"></span></label> into unticked checkboxes, and <label class="checkbox" for="checkbox2"><input type="checkbox" tabindex="2" class="input-checkbox" id="checkbox2" checked="checked" disabled="disabled"></input><span class="checkbox-label"></span></label> into ticked </span><em>and</em> disabled checkboxes (as well as a handy function to sync checking of those boxes with the underlying markdown), while keeping your <a href="#">links</a><span> intact. If a text immediatly follows a <label class="checkbox" for="checkbox3"><input type="checkbox" tabindex="3" class="input-checkbox" id="checkbox3" checked="checked"></input><span class="checkbox-label"></span></label>, it will be considered a label (as long as there is no space between them, like <label class="checkbox" for="checkbox4"><input type="checkbox" tabindex="4" class="input-checkbox" id="checkbox4"></input><span class="checkbox-label">this</span></label>). You&#39;ll also find in </span><code>checkboxes.js</code> two example functions to change your markup when a box is ticked in html (actual syncing of the markdown server-side is left as an exercise for the reader).</li><li><span>turn <span class="mention" data-for="mention:string">@string</span> into mentions and <span class="hashtag" data-for="hashtag:string">#string</span> into hashtags</span></li><li>turn line returns (<code>\r</code>,<code>\n</code>) into <code>&lt;br&gt;</code></li><li><span>turn <span class="arrow arrow-right">→</span> and <span class="arrow arrow-left">←</span> into arrows <span class="arrow arrow-right">→</span> sdfsdf</span></li><li><span>turn <a class="note-link" href="/45435kdfgfd">45435kdfgfd</a> into a link</span></li><li>create a table of contents automagically</li><li>Have a very simple mustache-type renderer that turns (I am replaced) into text, before rendering</li><li>And a very simple html wrapper, that wraps the whole result, after rendering.</li></ul>

<h3 id="toc-license">LICENSE</h3>

<p>MIT</p><script>
(function(md_text){

	/**
	 * Syncs Checkboxes in an element with the markdown text
	 * use to check the markdown when  the user checks the
	 * corresponding checkbox in the html.
	 * 
	 * @param  {DOM note} element  the html container
	 * @param  {string} markdown the original markdown string
	 * @param  {function} filter   a function to further filter
	 *                             checkboxes
	 * @return {string}          the synced markdown
	 * 
	 * 	`filter` receives an input of type checkbox and the
	 * 	position of the checkbox, and should return true if the
	 * 	checkbox should be accounted for, for example:
	 * 	
	 * 	```
	 * 	function(checkbox,i){
	 * 		return checkbox.className && /input-checkbox/.test(checkbox.className);
	 * 	}
	 * 	```
	 */
	function syncCheckBoxesAndText(element,markdown,filter){
		if(!markdown){return '';}
		if(!element){return markdown;}
		var inputs = element.getElementsByTagName('input')
		,	l = inputs && inputs.length
		,	i = 0
		,	checkboxes = []
		;
		if(!l){return markdown;}
		for(i;i<l;i++){
			if(inputs[i].type && inputs[i].type.match(/checkbox/i) && (!filter || filter(inputs[i]))){
				checkboxes.push(inputs[i].checked);
			}
		}
		markdown = markdown.replace(/\[(\s|x|\*|✓|✔|☑|×|X|✕|☓|✖|✗|✘|#)\]/g,function(total,inside){
			var checked = checkboxes.shift() || false;
			var sign = checked ? '✔' : ' ';
			return '['+sign+']';
		});
		return markdown;
	}

	/**
	 * Syncs a checkbox in the markdown text with
	 * the it's equivalent in html. Supposes checkboxes
	 * have a tabIndex and that the tabIndex is ordered.
	 *
	 * This works best if you have only one markdown text
	 * in your page, in a container, because tabIndexes will match
	 * If you run the filter on several markdown texts, then ids for
	 * a single container will not match anymore (apart from
	 * the first one)
	 * 
	 * @param  {DOM node} checkbox the checkbox, which is
	 *                    			assumed to have a "tabIndex"
	 *                    			property
	 * @param  {string} markdown the original markdown string
	 * @return {string}          the synced markdown
	 * 
	 */
	function replaceSingleCheckBox(checkbox,markdown){
		if(!markdown){return '';}
		if(!checkbox){return markdown;}
		var id = checkbox.tabIndex;
		var checked = checkbox.checked;
		var i = -1;
		markdown = markdown.replace(/\[(\s|x|\*|✓|✔|☑|×|X|✕|☓|✖|✗|✘|#)\]/g,function(total,inside){
			i++;
			if(i!==id){return total;}
			var sign = checked ? '✔' : ' ';
			return '['+sign+']';
		});
		return markdown;
	}

	/**
	 * Creates a function that checks a clicked element in a
	 * container to verify it is a checkbox; if yes, calls
	 * functions to sync it's state with the markdown
	 * @param  {DOM node} container the container
	 */
	function makeCheck(container){
		return function check(evt){
			if(evt.target && /input/i.test(evt.target.tagName) && evt.target.type && /checkbox/i.test(evt.target.type)){
				var response = {
					message:'this is the result of syncing the checkbox you just clicked with the markdown text'
				,	single: replaceSingleCheckBox(evt.target,md_text)
				,	sweeping: syncCheckBoxesAndText(container,md_text)
				,	original: md_text
				};
				console.log(response);
			}
		}
	}

	/**
	 * Attaches a click event to body to check
	 * when a checkbox is clicked.
	 */
	function attachCheckEvent(){
		var body = document.getElementsByTagName('body')[0];
		var check = makeCheck(body);
		if(body.attachEvent){
			body.attachEvent('onclick',check);
		}
		else if(body.addEventListener){
			body.addEventListener('click',check,false);
		}
	}


	attachCheckEvent();
})("# Markdown-More\n\nLittle additions on top of [markdown-js](https://github.com/evilstreak/markdown-js).  \nComes with a little set of helpers to register filters easily. Uses the [\"Maruku\"](https://github.com/bhollis/maruku/blob/master/docs/markdown_syntax.md) dialect by default, which means it supports:\n\n|tables | like | this|\n|-------|------|-----|\n| a     | b    | c   |\n\n\n### API\n\n#### Markdown(string[,locals])\nequivalent to the original `markdown.toHTML()`, but goes through all the filters before rendering. `locals` is anything you want to pass to your functions.\n\n#### Markdown.register(hook)\nReturns a function `register(function)` that allows to register functions on the defined hook. Hooks are (in order):\n\n- 'before': acts on the raw string\n- 'json': acts on the jsonmlTree\n- 'html': acts on the htmlTree\n- 'after': acts on the raw html string\n\nExample:\n```js\nvar register_html = markdown.register('html');\nregister_html(func1);\n```\n\n**Note**: Function order **MATTERS**.\n\n#### Markdown.register(hook,function)\nRegisters a function at a particular hook.  \nAll functions have a signature of `function(data,locals)`, where `locals` is whatever you passed down to `markdown()` and `data` is:\n\n- Functions defined in 'before' and 'after' receive an object {str:string}, where the string is respectively the raw text and the raw html\n- Functions defined in 'json' receive the jsonml tree\n- Functions defined in 'html' receive the html tree\n\nAll functions are expected to work on the first argument passed and shouldn't return anything.\n`Markdown.register(hook,function)` returns a curried version of itself, so you can chain, for example:\n```js\nmarkdown.register('json')(func1)(func2)(func3);\n//is equivalent to\nmarkdown.register('json')(func1);\nmarkdown.register('json')(func2);\nmarkdown.register('json')(func3);\n```\n\n#### Markdown.makeJsonFilter(function)\n\nRegisters a function at json level. Will go through every item in the jsonml array, and passe them to the function. The function is tasked with returning explicitely `false` for every item it does *not* want to parse.\n\n#### Markdown.makeJsonFilter(RegExp[,baseElem],parse)\n\nRegisters a json filter that uses the provided RegExp to parse the tree. The `parse` function passed should have a signature of: `function(chunk,locals)`, where `locals` is whatever you passed, `chunk` is the current processed chunk of text that matches the RegExp you provided, and `baseElem` is how you want your returned element to be wrapped ('text','para'...), and defaults to 'text'.\n`this.regExp` will be filled with the regExp you provided.  \nHere is an easy example to turn line returns into <br>:\n```js\nvar lineReturnsFilter = markdown.makeJsonFilter(/(\n|\r)/g,'text',function(chunk){\n    if(chunk.match(this.regExp)){\n        return ['linebreak'];\n    }\n    return chunk;\n});\nmarkdown.register('json',lineReturnsFilter);\n```\n\n#### Markdown.registerJsonFilter(RegExp,baseElem,parse)\n\nSame as `makeJsonFilter`, but avoids the step of having to register the function.\n\n### Examples:\n\nYou'll find a few examples in `example/filter.js`, namely to:\n\n  - turn \"[\*]abcde\" into checkboxes, [ ] into unticked checkboxes, and [#] into ticked *and* disabled checkboxes (as well as a handy function to sync checking of those boxes with the underlying markdown), while keeping your [links](#) intact. If a text immediatly follows a [x], it will be considered a label (as long as there is no space between them, like [ ]this). You'll also find in `checkboxes.js` two example functions to change your markup when a box is ticked in html (actual syncing of the markdown server-side is left as an exercise for the reader).\n  - turn @string into mentions and #string into hashtags\n  - turn line returns (`\r`,`\n`) into `<br>`\n  - turn -> and <- into arrows -> sdfsdf\n  - turn |>45435kdfgfd into a link\n  - create a table of contents automagically\n  - Have a very simple mustache-type renderer that turns {{exampleVar}} into text, before rendering\n  - And a very simple html wrapper, that wraps the whole result, after rendering.\n\n### LICENSE\nMIT\n");
</script>